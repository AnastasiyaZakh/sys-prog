<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><style>body {
  max-width: 980px;
  border: 1px solid #ddd;
  outline: 1300px solid #fff;
  margin: 16px auto;
}

body .markdown-body
{
  padding: 45px;
}

@font-face {
  font-family: fontawesome-mini;
  src: url(data:font/woff;charset=utf-8;base64,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) format('woff');
}

.markdown-body {
  font-family: sans-serif;
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #333333;
  overflow: hidden;
  font-family: "Helvetica Neue", Helvetica, "Segoe UI", Arial, freesans, sans-serif;
  font-size: 16px;
  line-height: 1.6;
  word-wrap: break-word;
}

.markdown-body a {
  background: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline: 0;
}

.markdown-body b,
.markdown-body strong {
  font-weight: bold;
}

.markdown-body mark {
  background: #ff0;
  color: #000;
  font-style: italic;
  font-weight: bold;
}

.markdown-body sub,
.markdown-body sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}
.markdown-body sup {
  top: -0.5em;
}
.markdown-body sub {
  bottom: -0.25em;
}

.markdown-body h1 {
  font-size: 2em;
  margin: 0.67em 0;
}

.markdown-body img {
  border: 0;
}

.markdown-body hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  height: 0;
}

.markdown-body pre {
  overflow: auto;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre,
.markdown-body samp {
  font-family: monospace, monospace;
  font-size: 1em;
}

.markdown-body input {
  color: inherit;
  font: inherit;
  margin: 0;
}

.markdown-body html input[disabled] {
  cursor: default;
}

.markdown-body input {
  line-height: normal;
}

.markdown-body input[type="checkbox"] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body .codehilitetable {
  border: 0;
  border-spacing: 0;
}

.markdown-body .codehilitetable tr {
  border: 0;
}

.markdown-body .codehilitetable pre,
.markdown-body .codehilitetable div.codehilite {
  margin: 0;
}

.markdown-body .linenos,
.markdown-body .code,
.markdown-body .codehilitetable td {
  border: 0;
  padding: 0;
}

.markdown-body td:not(.linenos) .linenodiv {
  padding: 0 !important;
}

.markdown-body .code {
  width: 100%;
}

.markdown-body .linenos div pre,
.markdown-body .linenodiv pre,
.markdown-body .linenodiv {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-left-radius: 3px;
  -webkit-border-bottom-left-radius: 3px;
  -moz-border-radius-topleft: 3px;
  -moz-border-radius-bottomleft: 3px;
  border-top-left-radius: 3px;
  border-bottom-left-radius: 3px;
}

.markdown-body .code div pre,
.markdown-body .code div {
  border: 0;
  -webkit-border-radius: 0;
  -moz-border-radius: 0;
  border-radius: 0;
  -webkit-border-top-right-radius: 3px;
  -webkit-border-bottom-right-radius: 3px;
  -moz-border-radius-topright: 3px;
  -moz-border-radius-bottomright: 3px;
  border-top-right-radius: 3px;
  border-bottom-right-radius: 3px;
}

.markdown-body * {
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body input {
  font: 13px Helvetica, arial, freesans, clean, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol";
  line-height: 1.4;
}

.markdown-body a {
  color: #4183c4;
  text-decoration: none;
}

.markdown-body a:hover,
.markdown-body a:focus,
.markdown-body a:active {
  text-decoration: underline;
}

.markdown-body hr {
  height: 0;
  margin: 15px 0;
  overflow: hidden;
  background: transparent;
  border: 0;
  border-bottom: 1px solid #ddd;
}

.markdown-body hr:before,
.markdown-body hr:after {
  display: table;
  content: " ";
}

.markdown-body hr:after {
  clear: both;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-top: 15px;
  margin-bottom: 15px;
  line-height: 1.1;
}

.markdown-body h1 {
  font-size: 30px;
}

.markdown-body h2 {
  font-size: 21px;
}

.markdown-body h3 {
  font-size: 16px;
}

.markdown-body h4 {
  font-size: 14px;
}

.markdown-body h5 {
  font-size: 12px;
}

.markdown-body h6 {
  font-size: 11px;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ul,
.markdown-body ol {
  padding: 0;
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ul ul ol,
.markdown-body ul ol ol,
.markdown-body ol ul ol,
.markdown-body ol ol ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code,
.markdown-body pre,
.markdown-body samp {
  font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body kbd {
  background-color: #e7e7e7;
  background-image: -moz-linear-gradient(#fefefe, #e7e7e7);
  background-image: -webkit-linear-gradient(#fefefe, #e7e7e7);
  background-image: linear-gradient(#fefefe, #e7e7e7);
  background-repeat: repeat-x;
  border-radius: 2px;
  border: 1px solid #cfcfcf;
  color: #000;
  padding: 3px 5px;
  line-height: 10px;
  font: 11px Consolas, "Liberation Mono", Menlo, Courier, monospace;
  display: inline-block;
}

.markdown-body>*:first-child {
  margin-top: 0 !important;
}

.markdown-body>*:last-child {
  margin-bottom: 0 !important;
}

.markdown-body .headerlink {
  font: normal 400 16px fontawesome-mini;
  vertical-align: middle;
  margin-left: -16px;
  float: left;
  display: inline-block;
  text-decoration: none;
  opacity: 0;
  color: #333;
}

.markdown-body .headerlink:focus {
  outline: none;
}

.markdown-body h1 .headerlink {
  margin-top: 0.8rem;
}

.markdown-body h2 .headerlink,
.markdown-body h3 .headerlink {
  margin-top: 0.6rem;
}

.markdown-body h4 .headerlink {
  margin-top: 0.2rem;
}

.markdown-body h5 .headerlink,
.markdown-body h6 .headerlink {
  margin-top: 0;
}

.markdown-body .headerlink:hover,
.markdown-body h1:hover .headerlink,
.markdown-body h2:hover .headerlink,
.markdown-body h3:hover .headerlink,
.markdown-body h4:hover .headerlink,
.markdown-body h5:hover .headerlink,
.markdown-body h6:hover .headerlink {
  opacity: 1;
  text-decoration: none;
}

.markdown-body h1 {
  padding-bottom: 0.3em;
  font-size: 2.25em;
  line-height: 1.2;
  border-bottom: 1px solid #eee;
}

.markdown-body h2 {
  padding-bottom: 0.3em;
  font-size: 1.75em;
  line-height: 1.225;
  border-bottom: 1px solid #eee;
}

.markdown-body h3 {
  font-size: 1.5em;
  line-height: 1.43;
}

.markdown-body h4 {
  font-size: 1.25em;
}

.markdown-body h5 {
  font-size: 1em;
}

.markdown-body h6 {
  font-size: 1em;
  color: #777;
}

.markdown-body p,
.markdown-body blockquote,
.markdown-body ul,
.markdown-body ol,
.markdown-body dl,
.markdown-body table,
.markdown-body pre,
.markdown-body .admonition {
  margin-top: 0;
  margin-bottom: 16px;
}

.markdown-body hr {
  height: 4px;
  padding: 0;
  margin: 16px 0;
  background-color: #e7e7e7;
  border: 0 none;
}

.markdown-body ul,
.markdown-body ol {
  padding-left: 2em;
}

.markdown-body ul ul,
.markdown-body ul ol,
.markdown-body ol ol,
.markdown-body ol ul {
  margin-top: 0;
  margin-bottom: 0;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  padding: 0;
  margin-top: 16px;
  font-size: 1em;
  font-style: italic;
  font-weight: bold;
}

.markdown-body dl dd {
  padding: 0 16px;
  margin-bottom: 16px;
}

.markdown-body blockquote {
  padding: 0 15px;
  color: #777;
  border-left: 4px solid #ddd;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body table {
  display: block;
  width: 100%;
  overflow: auto;
  word-break: normal;
  word-break: keep-all;
}

.markdown-body table th {
  font-weight: bold;
}

.markdown-body table th,
.markdown-body table td {
  padding: 6px 13px;
  border: 1px solid #ddd;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #ccc;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

.markdown-body img {
  max-width: 100%;
  -moz-box-sizing: border-box;
  box-sizing: border-box;
}

.markdown-body code,
.markdown-body samp {
  padding: 0;
  padding-top: 0.2em;
  padding-bottom: 0.2em;
  margin: 0;
  font-size: 85%;
  background-color: rgba(0,0,0,0.04);
  border-radius: 3px;
}

.markdown-body code:before,
.markdown-body code:after {
  letter-spacing: -0.2em;
  content: "\00a0";
}

.markdown-body pre>code {
  padding: 0;
  margin: 0;
  font-size: 100%;
  word-break: normal;
  white-space: pre;
  background: transparent;
  border: 0;
}

.markdown-body .codehilite {
  margin-bottom: 16px;
}

.markdown-body .codehilite pre,
.markdown-body pre {
  padding: 16px;
  overflow: auto;
  font-size: 85%;
  line-height: 1.45;
  background-color: #f7f7f7;
  border-radius: 3px;
}

.markdown-body .codehilite pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre code {
  display: inline;
  max-width: initial;
  padding: 0;
  margin: 0;
  overflow: initial;
  line-height: inherit;
  word-wrap: normal;
  background-color: transparent;
  border: 0;
}

.markdown-body pre code:before,
.markdown-body pre code:after {
  content: normal;
}

/* Admonition */
.markdown-body .admonition {
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  position: relative;
  border-radius: 3px;
  border: 1px solid #e0e0e0;
  border-left: 6px solid #333;
  padding: 10px 10px 10px 30px;
}

.markdown-body .admonition table {
  color: #333;
}

.markdown-body .admonition p {
  padding: 0;
}

.markdown-body .admonition-title {
  font-weight: bold;
  margin: 0;
}

.markdown-body .admonition>.admonition-title {
  color: #333;
}

.markdown-body .attention>.admonition-title {
  color: #a6d796;
}

.markdown-body .caution>.admonition-title {
  color: #d7a796;
}

.markdown-body .hint>.admonition-title {
  color: #96c6d7;
}

.markdown-body .danger>.admonition-title {
  color: #c25f77;
}

.markdown-body .question>.admonition-title {
  color: #96a6d7;
}

.markdown-body .note>.admonition-title {
  color: #d7c896;
}

.markdown-body .admonition:before,
.markdown-body .attention:before,
.markdown-body .caution:before,
.markdown-body .hint:before,
.markdown-body .danger:before,
.markdown-body .question:before,
.markdown-body .note:before {
  font: normal normal 16px fontawesome-mini;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  line-height: 1.5;
  color: #333;
  position: absolute;
  left: 0;
  top: 0;
  padding-top: 10px;
  padding-left: 10px;
}

.markdown-body .admonition:before {
  content: "\f056\00a0";
  color: 333;
}

.markdown-body .attention:before {
  content: "\f058\00a0";
  color: #a6d796;
}

.markdown-body .caution:before {
  content: "\f06a\00a0";
  color: #d7a796;
}

.markdown-body .hint:before {
  content: "\f05a\00a0";
  color: #96c6d7;
}

.markdown-body .danger:before {
  content: "\f057\00a0";
  color: #c25f77;
}

.markdown-body .question:before {
  content: "\f059\00a0";
  color: #96a6d7;
}

.markdown-body .note:before {
  content: "\f040\00a0";
  color: #d7c896;
}

.markdown-body .admonition::after {
  content: normal;
}

.markdown-body .attention {
  border-left: 6px solid #a6d796;
}

.markdown-body .caution {
  border-left: 6px solid #d7a796;
}

.markdown-body .hint {
  border-left: 6px solid #96c6d7;
}

.markdown-body .danger {
  border-left: 6px solid #c25f77;
}

.markdown-body .question {
  border-left: 6px solid #96a6d7;
}

.markdown-body .note {
  border-left: 6px solid #d7c896;
}

.markdown-body .admonition>*:first-child {
  margin-top: 0 !important;
}

.markdown-body .admonition>*:last-child {
  margin-bottom: 0 !important;
}

/* progress bar*/
.markdown-body .progress {
  display: block;
  width: 300px;
  margin: 10px 0;
  height: 24px;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #ededed;
  position: relative;
  box-shadow: inset -1px 1px 3px rgba(0, 0, 0, .1);
}

.markdown-body .progress-label {
  position: absolute;
  text-align: center;
  font-weight: bold;
  width: 100%; margin: 0;
  line-height: 24px;
  color: #333;
  text-shadow: 1px 1px 0 #fefefe, -1px -1px 0 #fefefe, -1px 1px 0 #fefefe, 1px -1px 0 #fefefe, 0 1px 0 #fefefe, 0 -1px 0 #fefefe, 1px 0 0 #fefefe, -1px 0 0 #fefefe, 1px 1px 2px #000;
  -webkit-font-smoothing: antialiased !important;
  white-space: nowrap;
  overflow: hidden;
}

.markdown-body .progress-bar {
  height: 24px;
  float: left;
  -webkit-border-radius: 3px;
  -moz-border-radius: 3px;
  border-radius: 3px;
  background-color: #96c6d7;
  box-shadow: inset 0 1px 0 rgba(255, 255, 255, .5), inset 0 -1px 0 rgba(0, 0, 0, .1);
  background-size: 30px 30px;
  background-image: -webkit-linear-gradient(
    135deg, rgba(255, 255, 255, .4) 27%,
    transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%,
    transparent 77%, transparent
  );
  background-image: -moz-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -ms-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: -o-linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
  background-image: linear-gradient(
    135deg,
    rgba(255, 255, 255, .4) 27%, transparent 27%,
    transparent 52%, rgba(255, 255, 255, .4) 52%,
    rgba(255, 255, 255, .4) 77%, transparent 77%,
    transparent
  );
}

.markdown-body .progress-100plus .progress-bar {
  background-color: #a6d796;
}

.markdown-body .progress-80plus .progress-bar {
  background-color: #c6d796;
}

.markdown-body .progress-60plus .progress-bar {
  background-color: #d7c896;
}

.markdown-body .progress-40plus .progress-bar {
  background-color: #d7a796;
}

.markdown-body .progress-20plus .progress-bar {
  background-color: #d796a6;
}

.markdown-body .progress-0plus .progress-bar {
  background-color: #c25f77;
}

.markdown-body .candystripe-animate .progress-bar{
  -webkit-animation: animate-stripes 3s linear infinite;
  -moz-animation: animate-stripes 3s linear infinite;
  animation: animate-stripes 3s linear infinite;
}

@-webkit-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@-moz-keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

@keyframes animate-stripes {
  0% {
    background-position: 0 0;
  }

  100% {
    background-position: 60px 0;
  }
}

.markdown-body .gloss .progress-bar {
  box-shadow:
    inset 0 4px 12px rgba(255, 255, 255, .7),
    inset 0 -12px 0 rgba(0, 0, 0, .05);
}

/* MultiMarkdown Critic Blocks */
.markdown-body .critic_mark {
  background: #ff0;
}

.markdown-body .critic_delete {
  color: #c82829;
  text-decoration: line-through;
}

.markdown-body .critic_insert {
  color: #718c00 ;
  text-decoration: underline;
}

.markdown-body .critic_comment {
  color: #8e908c;
  font-style: italic;
}

.markdown-body .headeranchor {
  font: normal normal 16px fontawesome-mini;
  line-height: 1;
  display: inline-block;
  text-decoration: none;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.headeranchor:before {
  content: '\e157';
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 4px 0.25em -20px;
  vertical-align: middle;
}

/* Media */
@media only screen and (min-width: 480px) {
  .markdown-body {
    font-size:14px;
  }
}

@media only screen and (min-width: 768px) {
  .markdown-body {
    font-size:16px;
  }
}

@media print {
  .markdown-body * {
    background: transparent !important;
    color: black !important;
    filter:none !important;
    -ms-filter: none !important;
  }

  .markdown-body {
    font-size:12pt;
    max-width:100%;
    outline:none;
    border: 0;
  }

  .markdown-body a,
  .markdown-body a:visited {
    text-decoration: underline;
  }

  .markdown-body .headeranchor-link {
    display: none;
  }

  .markdown-body a[href]:after {
    content: " (" attr(href) ")";
  }

  .markdown-body abbr[title]:after {
    content: " (" attr(title) ")";
  }

  .markdown-body .ir a:after,
  .markdown-body a[href^="javascript:"]:after,
  .markdown-body a[href^="#"]:after {
    content: "";
  }

  .markdown-body pre {
    white-space: pre;
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  .markdown-body pre,
  .markdown-body blockquote {
    border: 1px solid #999;
    padding-right: 1em;
    page-break-inside: avoid;
  }

  .markdown-body .progress,
  .markdown-body .progress-bar {
    -moz-box-shadow: none;
    -webkit-box-shadow: none;
    box-shadow: none;
  }

  .markdown-body .progress {
    border: 1px solid #ddd;
  }

  .markdown-body .progress-bar {
    height: 22px;
    border-right: 1px solid #ddd;
  }

  .markdown-body tr,
  .markdown-body img {
    page-break-inside: avoid;
  }

  .markdown-body img {
    max-width: 100% !important;
  }

  .markdown-body p,
  .markdown-body h2,
  .markdown-body h3 {
    orphans: 3;
    widows: 3;
  }

  .markdown-body h2,
  .markdown-body h3 {
    page-break-after: avoid;
  }
}
</style><script type='text/javascript' src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js'></script><script>MathJax.Hub.Config({
  config: ["MMLorHTML.js"],
  extensions: ["tex2jax.js"],
  jax: ["input/TeX", "output/HTML-CSS", "output/NativeMML"],
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"] ],
    displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
    processEscapes: true,
    processEnvironments: true,
    ignoreClass: ".*|",
    processClass: "arithmatex"
  },
  TeX: {
    extensions: ["AMSmath.js", "AMSsymbols.js"],
    TagSide: "right",
    TagIndent: ".8em",
    MultLineWidth: "85%",
    equationNumbers: {
      autoNumber: "AMS",
    },
    unicode: {
      fonts: "STIXGeneral,'Arial Unicode MS'"
    }
  },
  showProcessingMessages: false,
  messageStyle: 'none'
});
</script><style>/*GitHub*/
.codehilite {background-color:#fff;color:#333333;}
.codehilite .hll {background-color:#ffffcc;}
.codehilite .c{color:#999988;font-style:italic}
.codehilite .err{color:#a61717;background-color:#e3d2d2}
.codehilite .k{font-weight:bold}
.codehilite .o{font-weight:bold}
.codehilite .cm{color:#999988;font-style:italic}
.codehilite .cp{color:#999999;font-weight:bold}
.codehilite .c1{color:#999988;font-style:italic}
.codehilite .cs{color:#999999;font-weight:bold;font-style:italic}
.codehilite .gd{color:#000000;background-color:#ffdddd}
.codehilite .ge{font-style:italic}
.codehilite .gr{color:#aa0000}
.codehilite .gh{color:#999999}
.codehilite .gi{color:#000000;background-color:#ddffdd}
.codehilite .go{color:#888888}
.codehilite .gp{color:#555555}
.codehilite .gs{font-weight:bold}
.codehilite .gu{color:#800080;font-weight:bold}
.codehilite .gt{color:#aa0000}
.codehilite .kc{font-weight:bold}
.codehilite .kd{font-weight:bold}
.codehilite .kn{font-weight:bold}
.codehilite .kp{font-weight:bold}
.codehilite .kr{font-weight:bold}
.codehilite .kt{color:#445588;font-weight:bold}
.codehilite .m{color:#009999}
.codehilite .s{color:#dd1144}
.codehilite .n{color:#333333}
.codehilite .na{color:teal}
.codehilite .nb{color:#0086b3}
.codehilite .nc{color:#445588;font-weight:bold}
.codehilite .no{color:teal}
.codehilite .ni{color:purple}
.codehilite .ne{color:#990000;font-weight:bold}
.codehilite .nf{color:#990000;font-weight:bold}
.codehilite .nn{color:#555555}
.codehilite .nt{color:navy}
.codehilite .nv{color:teal}
.codehilite .ow{font-weight:bold}
.codehilite .w{color:#bbbbbb}
.codehilite .mf{color:#009999}
.codehilite .mh{color:#009999}
.codehilite .mi{color:#009999}
.codehilite .mo{color:#009999}
.codehilite .sb{color:#dd1144}
.codehilite .sc{color:#dd1144}
.codehilite .sd{color:#dd1144}
.codehilite .s2{color:#dd1144}
.codehilite .se{color:#dd1144}
.codehilite .sh{color:#dd1144}
.codehilite .si{color:#dd1144}
.codehilite .sx{color:#dd1144}
.codehilite .sr{color:#009926}
.codehilite .s1{color:#dd1144}
.codehilite .ss{color:#990073}
.codehilite .bp{color:#999999}
.codehilite .vc{color:teal}
.codehilite .vg{color:teal}
.codehilite .vi{color:teal}
.codehilite .il{color:#009999}
.codehilite .gc{color:#999;background-color:#EAF2F5}
</style><title>all-lectures</title></head><body><article class="markdown-body"><p>{% include mathjax %}</p>
<p><a href="///C://Users/NikitaSkybytskyi/Desktop/c3s2/system-programming/README.md">Назад на головну</a></p>
<p>Зміст:</p>
<ul>
<li>
<p><a href="#мови-програмування-та-мовні-процесори">Мови програмування та мовні процесори</a></p>
<ul>
<li>
<p><a href="#мови-програмування">Мови програмування</a></p>
<ul>
<li>
<p><a href="#прагматичний-аспект">Прагматичний аспект</a></p>
</li>
<li>
<p><a href="#семантичний-аспект">Семантичний аспект</a></p>
</li>
<li>
<p><a href="#синтаксичний-аспект">Синтаксичний аспект</a></p>
</li>
</ul>
</li>
<li>
<p><a href="#мовні-процесори">Мовні процесори</a></p>
<ul>
<li>
<p><a href="#структура-транслятора">Структура транслятора</a></p>
</li>
<li>
<p><a href="#призначення-основних-компонентів-транслятора">Призначення основних компонентів транслятора</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#лексичний-аналіз-та-скінченні-автомати">Лексичний аналіз та скінченні автомати</a></p>
<ul>
<li>
<p><a href="#лексичний-аналіз-в-мовних-процесорах">Лексичний аналіз в мовних процесорах</a></p>
</li>
<li>
<p><a href="#скінчені-автомати">Скінчені автомати</a></p>
<ul>
<li>
<p><a href="#мова-яку-розпізнає-скінченний-автомат">Мова яку розпізнає скінченний автомат</a></p>
</li>
<li>
<p><a href="#способи-визначення-функції-переходів">Способи визначення функції переходів</a></p>
</li>
<li>
<p><a href="#детерміновані-скінченні-автомати">Детерміновані скінченні автомати</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#мінімізація-детермінованих-скінченних-автоматів">Мінімізація детермінованих скінченних автоматів</a></p>
<ul>
<li>
<p><a href="#мінімізація-детермінованих-скінченних-автоматів-1">Мінімізація детермінованих скінченних автоматів</a></p>
<ul>
<li>
<p><a href="#недосяжні-стани">Недосяжні стани</a></p>
</li>
<li>
<p><a href="#тупикові-стани">Тупикові стани</a></p>
</li>
<li>
<p><a href="#еквівалентні-стани">Еквівалентні стани</a></p>
</li>
<li>
<p><a href="#алгоритм">Алгоритм</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#скінченно-автоматні-мови-і-праволінійні-граматики">Скінченно-автоматні мови і праволінійні граматики</a></p>
<ul>
<li>
<p><a href="#скінченно-автоматні-мови">Скінченно-автоматні мови</a></p>
<ul>
<li>
<p><a href="#базові-мови">Базові скінченно-автоматні мови</a></p>
</li>
<li>
<p><a href="#операції-над-мовами">Операції над мовами</a></p>
</li>
</ul>
</li>
<li>
<p><a href="#скінченні-автомати-та-праволінійні-граматики">Скінченні автомати та праволінійні граматики</a></p>
<ul>
<li>
<p><a href="#класифікація-граматик-Хомського">Класифікація граматик Хомського</a></p>
</li>
<li>
<p><a href="#мова-породжена-граматикою">Мова породжена граматикою</a></p>
</li>
<li>
<p><a href="#праволінійна-граматика--скінченний-автомат">Праволінійна граматика $$\sim$$ скінченний автомат</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#регулярні-множини-і-регулярні-вирази">Регулярні множини і регулярні вирази</a></p>
<ul>
<li>
<p><a href="#регулярні-множини">Регулярні множини</a></p>
</li>
<li>
<p><a href="#регулярні-вирази">Регулярні вирази</a></p>
<ul>
<li>
<p><a href="#алгебра-регулярних-виразів">Алгебра регулярних виразів</a></p>
</li>
<li>
<p><a href="#лінійні-рівняння">Лінійні рівняння</a></p>
</li>
<li>
<p><a href="#системи-рівнянь">Системи рівнянь</a></p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#поліз-регулярні-вирази-і-автомати">ПОЛІЗ, регулярні вирази і автомати</a></p>
<ul>
<li>
<p><a href="#польський-інверсний-запис-для-регулярних-виразів">Польський інверсний запис для регулярних виразів</a></p>
<ul>
<li><a href="#алгоритм-1">Алгоритм</a></li>
</ul>
</li>
<li>
<p><a href="#інтерпретація-поліз-регулярного-виразу">Інтерпретація ПОЛІЗ регулярного виразу</a></p>
<ul>
<li><a href="#алгоритм-2">Алгоритм</a></li>
</ul>
</li>
</ul>
</li>
<li>
<p><a href="#синтаксичний-аналіз-в-мовних-процесорах">Синтаксичний аналіз в мовних процесорах</a></p>
<ul>
<li>
<p><a href="#синтаксичний-аналіз">Синтаксичний аналіз</a></p>
<ul>
<li>
<p><a href="#стратегії-виведення">Стратегії виведення</a></p>
</li>
<li>
<p><a href="#синтаксичні-дерева">Синтаксичні дерева</a></p>
</li>
<li>
<p><a href="#власне-аналіз">Власне аналіз</a></p>
</li>
<li>
<p><a href="#синтез-дерева-за-аналізом">Синтез дерева за аналізом</a></p>
</li>
<li>
<p><a href="#проблеми-стратегії-зверху-донизу">Проблеми стратегії &ldquo;зверху донизу&rdquo;</a></p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="_1">Мови програмування та мовні процесори<a class="headerlink" href="#_1" title="Permanent link"></a></h1>
<h2 id="_2">Мови програмування<a class="headerlink" href="#_2" title="Permanent link"></a></h2>
<p>При вивченні мов програмування, як правило, виділяють три аспекти:
- Прагматичний;
- Семантичний;
- Синтаксичний.</p>
<h3 id="_3">Прагматичний аспект<a class="headerlink" href="#_3" title="Permanent link"></a></h3>
<p><em>Прагматичний аспект</em> (прагматика мови програмування) визначає клас задач, на
розв&rsquo;язування яких орієнтується мова програмування. Як правило, прагматичний аспект
менш формалізований у порівнянні з семантичним та синтаксичним аспектами.</p>
<p>За класом задач на розв&rsquo;язування яких орієнтуються мови програмування 
їх можна поділити передусім на 
- процедурні;
- непроцедурні.</p>
<p><em>Процедурні</em> мови програмування орієнтовані перш за все на опис
(визначення) алгоритмів, тобто по суті використовуються для побудови процедур
обробки даних. До таких мов ми відносимо всім відомі мови програмування, такі
як Pascal, Fortran, C та ін.</p>
<p><em>Непроцедурні</em> мови програмування на відміну від процедурних неявно
визначають процедури обробки даних. Частіше всього такі мови
використовуються для побудови завдань на обробку даних. При цьому, за
допомогою інструкцій непроцедурної мови програмування визначається що
необхідно зробити з даними і явно не визначається як (з використанням яких
алгоритмів) необхідно розв&rsquo;язати задачу. До непроцедурних мов програмування
ми відносимо командні мови операційних систем, мови управління в пакетах
прикладних програм та ін.</p>
<p>Як процедурні, так і непроцедурні мови програмування можуть
орієнтуватися як на декілька класів задач, так і конкретну предметну область. У
першому випадку ми будемо говорити про <em>універсальні</em> мови програмування
(Pascal, Fortran, C), в другому &mdash; про <em>спеціалізовані</em>
мови програмування (Snobol, Lisp).</p>
<h3 id="_4">Семантичний аспект<a class="headerlink" href="#_4" title="Permanent link"></a></h3>
<p><em>Семантичний аспект</em> (семантика мови програмування) визначається
шляхом конкретизації базових функцій обробки даних, набору конструкцій
управління та методами побудови більш &ldquo;складних&rdquo; програм на основі &ldquo;простих&rdquo;.</p>
<p>Наприклад, визначивши як базовий тип даних &ldquo;рядок&rdquo; ми повинні
запропонувати &ldquo;традиційний&rdquo; набір функцій обробки таких даних: порівняння
рядків, виділення частини рядка, конкатенацію рядків та ін.</p>
<p>Семантика мови програмування має бути визначена формально, бо інакше у
подальшому неможливо буде побудувати відповідний мовний процесор. Станом на
сьогодні існують два основних напрямки визначення семантики мов
програмування: 
- методи денотаційної семантики;
- методи операційної семантики.</p>
<p>Методи <em>денотаційної семантики</em> базуються на відповідних алгебрах, методи
<em>операційної семантики</em> базуються на синтаксичних структурах програм.</p>
<h3 id="_5">Синтаксичний аспект<a class="headerlink" href="#_5" title="Permanent link"></a></h3>
<p><em>Синтаксичний аспект</em> (синтаксис мови програмування) визначає набір
синтаксичних конструкцій мови програмування, які використовуються для нотації
(запису) семантичних одиниць в програмі. Про синтаксис мови програмування
можна сказати як про форму, яка є суть похідною від семантики. Для визначення
(опису) синтаксису мови програмування використовуються як механізми, що
орієнтовані на синтез, так і механізми, орієнтовані на аналіз. </p>
<p>Задачі аналізу та синтезу синтаксичних структур програм &mdash; це дуальні задачі. 
Їх конкретизацію ми будемо розглядати в наступних розділах.</p>
<p>Виходячи з вищенасказаного, щоб побудувати мову програмування потрібно:
- визначити клас (класи) задач, на розв&rsquo;язок яких орієнтована мова 
    програмування;
- виділити базові типи даних та функції їх обробки, вказати конструкції
    управління в програмах. Побудувати механізми конструювання більш складних
    програм та структур даних на основі більш простих одиниць;
- визначити синтаксис мови програмування.</p>
<h2 id="_6">Мовні процесори<a class="headerlink" href="#_6" title="Permanent link"></a></h2>
<p><em>Мовні процесори</em> реалізують мови програмування. Точніше, мовний
процесор призначений для обробки програм відповідної мови програмування. З
точки зору прагматики, мовні процесори діляться на
- транслятори;
- інтерпретатори.</p>
<p><em>Мовний процесор типу транслятор (транслятор)</em> &mdash; це програмний
комплекс, котрий на вході отримує текст програми на вхідній мові, а на виході
видає версію програми на вихідній мові, що називається об&rsquo;єктною мовою. В
більшості випадків як об&rsquo;єктна мова виступає мова команд деякої обчислювальної
машини. Серед трансляторів можна виділити дві програмні системи:
- компілятори &mdash; транслятори з мов програмування високого рівня;
- асемблери &mdash; транслятори машинно-орієнтованих мов програмування.</p>
<p><em>Мовний процесор типу інтерпретатор (інтерпретатор)</em> &mdash; це програмний
комплекс, котрий на вході отримує текст програми на вхідній мові та вхідні дані,
які в подальшому обробляються програмою, а на виході видає результати
обчислень (вихідні дані).</p>
<p>Оскільки транслятори та інтерпретатори реалізують мови програмування,
вони мають спільні риси: їх структура досить схожа, в основу їх реалізації
покладено спільні теоретичні результати та практичні методи реалізації.</p>
<h3 id="_7">Структура транслятора<a class="headerlink" href="#_7" title="Permanent link"></a></h3>
<ol>
<li>Вхідний текст програми</li>
<li>Лексичний аналіз</li>
<li>Синтаксичний аналіз</li>
<li>Семантичний аналіз</li>
<li>Оптимізація проміжного коду</li>
<li>Генерація коду</li>
<li>Вихідний (об&rsquo;єктний) код</li>
</ol>
<h3 id="_8">Призначення основних компонентів транслятора<a class="headerlink" href="#_8" title="Permanent link"></a></h3>
<ol>
<li>
<p><em>Лексичний аналізатор.</em></p>
<p><strong>Вхід:</strong> вхідний текст (послідовність літер) програми.</p>
<p><strong>Вихід:</strong> послідовність лексем програми.</p>
<p><em>Лексема</em> &mdash; це ланцюжок літер, що має певний зміст. Всі лексеми мови
програмування (їх кількість, як правило, нескінчена) можна розбити на скінчену
множину класів. Для більшості мов програмування актуальні наступні класи
лексем:
- зарезервовані слова;
- ідентифікатори;
- числові константи (цілі та дійсні числа);
- літерні константи;
- рядкові константи;
- коди операцій;
- коментарі. Безпосередньо не несуть інформації щодо структури
    програми. В подальшому не використовуються, тобто не передаються
    синтаксичному аналізатору.
- дужки та інші елементи програми.
2. <em>Синтаксичний аналізатор.</em></p>
<p><strong>Вхід:</strong> послідовність лексем програми.</p>
<p><strong>Вихід:</strong></p>
<ul>
<li>&ldquo;Так&rdquo; + синтаксична структура (синтаксичний терм) програми,</li>
<li>&ldquo;Ні&rdquo; + синтаксичні помилки в програмі.
3. <em>Семантичний аналізатор.</em></li>
</ul>
<p><strong>Вхід:</strong> Синтаксичний терм програми.</p>
<p><strong>Вихід:</strong>
- &ldquo;Так&rdquo; + семантична структура (семантичний терм) програми,
- &ldquo;Ні&rdquo; + семантичні помилки в програмі.
4. <em>Оптимізація проміжного коду.</em></p>
<p><strong>Вхід:</strong> семантичний терм програми.</p>
<p><strong>Вихід:</strong> оптимізований семантичний терм програми.</p>
<p><em>Оптимізація</em> &mdash; це еквівалентне перетворення програми на основі певних
критеріїв. Серед критеріїв оптимізації можна виділити:
- оптимізацію по пам&rsquo;яті;
- оптимізацію по швидкості виконання. </p>
<p>В залежності від підходів по оптимізації програми можна розглядати такі
методи оптимізації:
- машинно-залежні;
- машинно-незалежні</p>
<p>На відміну від машинно-незалежних
методів машинно-залежні методи оптимізації враховують архітектурні особливості
ЕОМ, наприклад, наявність апаратного стека, наявність вільних регістрів, тощо.
5. <em>Генерація об&rsquo;єктного коду.</em></p>
<p><strong>Вхід:</strong> семантичний терм програми.</p>
<p><strong>Вихід:</strong> результуючий (об&rsquo;єктний) код програми.</p>
</li>
</ol>
<h1 id="_9">Лексичний аналіз та скінченні автомати<a class="headerlink" href="#_9" title="Permanent link"></a></h1>
<h2 id="_10">Лексичний аналіз в мовних процесорах<a class="headerlink" href="#_10" title="Permanent link"></a></h2>
<p><strong>Призначення:</strong> перетворення вхідного тексту програми з формату
зовнішнього представлення в машинно-орієнтований формат &mdash; послідовність
лексем.</p>
<p>Нагадаємо, що <em>лексема</em> &mdash; це ланцюжок літер елементарний об&rsquo;єкт програми, що несе
певний семантичний зміст. В подальшому кожну лексему будемо представляти як
пару
<div class="codehilite"><pre>(клас_лексеми, ім&#39;я_лексеми)
</pre></div></p>
<p>В більшості мов програмування для визначення класів лексем достатньо
скінченних автоматів.</p>
<h2 id="_11">Скінчені автомати<a class="headerlink" href="#_11" title="Permanent link"></a></h2>
<p><em>Недетермінований скінчений автомат</em> &mdash; це п&rsquo;ятірка</p>
<p>$$
M = \left\langle Q, \Sigma, \delta, q_0, F \right\rangle,
$$</p>
<p>де</p>
<ul>
<li>$$Q = {q_0, q_1, \ldots, q_{n-1}}$$ &mdash; скінчена множина станів автомата;</li>
<li>$$\Sigma = {a_1, a_2, \ldots, a_m}$$ &mdash; скінчена множина вхідних символів (вхідний алфавіт);</li>
<li>$$q_0 \in Q$$ &mdash; початковий стан автомата;</li>
<li>$$\delta$$ &mdash; відображення множини $$Q \times \Sigma$$ в множину $$2^Q$$. 
    Відображення $$\delta$$ як
    правило називають функцією переходів;</li>
<li>$$F \subset Q$$ &mdash; множина заключних станів. Елементи з $$F$$ називають заключними
    або фінальними станами.</li>
</ul>
<p>Якщо $$M$$ &mdash; скінчений автомат, то пара 
$$(q, w) \in Q \times \Sigma^\star$$ називається
<em>конфігурацією автомата</em> $$M$$. Оскільки скінчений автомат &mdash; це дискретний
пристрій, він працює по тактам. Такт скінченого автомата $$M$$ задається бінарним
відношенням $$\models$$, яке визначається на конфігураціях:</p>
<p>$$
(q_1, a w) \models (q_2, w) \quad \text{if} \quad q_2 \in \delta(q_1, a), \quad \forall w \in \Sigma^\star.
$$</p>
<h3 id="_12">Мова яку розпізнає скінченний автомат<a class="headerlink" href="#_12" title="Permanent link"></a></h3>
<p>Скінчений автомат $$M$$ <em>розпізнає (допускає)</em> ланцюжок $$w$$, якщо</p>
<p>$$
\exists q \in F: \quad (q_0, w) \models^\star (q, \varepsilon),
$$</p>
<p>де $$\models^\star$$ &mdash; рефлексивно-транзитивне замикання бінарного відношення $$\models$$.</p>
<p><em>Mова</em>, яку допускає автомат $$M$$ (розпізнає автомат $$M$$)</p>
<p>$$
L(M) = \left{ w \middle| w \in \Sigma^\star, (q_0, w) \models^\star (q, \varepsilon), q \in F \right}.
$$</p>
<h3 id="_13">Способи визначення функції переходів<a class="headerlink" href="#_13" title="Permanent link"></a></h3>
<p>На практиці, при визначенні скінченого автомата $$M$$, використовують
декілька способів визначення функції $$\delta$$, наприклад:
- це табличне визначення $$\delta$$;
- діаграма проходів скінченого автомата.</p>
<p><em>Табличне визначення</em> функції $$\delta$$ &mdash; це таблиця $$M(q_i, a_j)$$, де $$aj \in \Sigma, q_i \in Q$$, тобто</p>
<p>$$
M(q_i, a_j) = \left{ q_k \middle| q_k \in \delta(q_i, a_j) \right}.
$$</p>
<p><em>Діаграма переходів</em> скінченого автомата $$M$$ &mdash; це невпорядкований граф $$G(V,
P)$$, де $$V$$ &mdash; множина вершин графа, а $$P$$ &mdash; множина орієнтованих дуг,
причому з вершини $$q_i$$ у вершину $$q_j$$ веде дуга позначена $$a_k$$, 
коли $$q_j \in \delta(q_i, a_k)$$. На
діаграмі переходів скінченого автомата це позначається так:</p>
<p><img alt="img-1" src="///C://Users/NikitaSkybytskyi/Desktop/c3s2/system-programming/lectures/img/img-1.png" /></p>
<p>В подальшому, на діаграмі переходів скінченого автомата $$M$$ елементи з
множини заключних станів будемо позначити так:</p>
<p><img alt="img-2" src="///C://Users/NikitaSkybytskyi/Desktop/c3s2/system-programming/lectures/img/img-2.png" /></p>
<p><strong>Приклад.</strong> Побудуємо діаграму переходів скінченого автомата $$M$$, який
розпізнає множину цілочислових констант мови С.</p>
<p><img alt="img-3" src="///C://Users/NikitaSkybytskyi/Desktop/c3s2/system-programming/lectures/img/img-3.png" /></p>
<p><strong>Зауваження.</strong> Цей автомат неповний, на два нижні праві вузли потрібно 
довісити &ldquo;UL&rdquo;-частину яка висить на вузлі &ldquo;1..9&rdquo;.</p>
<p>З побудованого прикладу видно, що приведений автомат не повністю
визначений.</p>
<h3 id="_14">Детерміновані скінченні автомати<a class="headerlink" href="#_14" title="Permanent link"></a></h3>
<p>Скінчений автомат $$M$$ називається <em>детермінованим</em>, якщо $$\delta(a_i, a_k)$$
містить не більше одного стану для любого $$q_i \in Q$$ та $$a_k \in \Sigma$$.</p>
<p><strong>Теорема.</strong> <em>Для довільного недетермінованого скінченого автомата $$M$$ можна
побудувати еквівалентний йому детермінований скінчений автомат $$M&rsquo;$$, такий що</em></p>
<p>$$
L(M) = L(M&rsquo;).
$$</p>
<p><strong>Доведення:</strong> Нехай $$M$$ &mdash; недетермінований скінчений автомат, такий що</p>
<p>$$
M = \left\langle Q, \Sigma, \delta, q_0, F \right\rangle.
$$</p>
<p>Детермінований автомат $$M&rsquo; = \left\langle Q&rsquo;, \Sigma, \delta&rsquo;, q_0&rsquo;, F \right\rangle$$ 
побудуємо таким чином:</p>
<ol>
<li>$$Q&rsquo; = 2^Q$$, тобто імена станів автомата $$M&rsquo;$$ &mdash; це підмножини множини $$Q$$.</li>
<li>$$q_0&rsquo; = {q_0} \in 2^Q = Q&rsquo;$$.</li>
<li>$$F&rsquo;$$ складається з усіх таких підмножин $$S \in 2^Q = Q&rsquo;$$, 
    що $$S \cap F \ne \varnothing$$.</li>
<li>$$\delta&rsquo;(S, a) \models \left{ q \mid q \in \delta(q_i, a), q_i \in S \right}$$.</li>
</ol>
<p>Доводимо індукцією по $$i$$, що $$(S, w) \models^i (S&rsquo;, \varepsilon)$$, тоді і тільки тоді,
коли $$S&rsquo; = \left{ q \middle| \exists q_i \in S: (q_i, w) \models^i (q, \varepsilon) \right}$$.</p>
<p>Зокрема, $$ \left({q_0}, w\right) \models^\star (S&rsquo;, \varepsilon)$$, 
для деякого $$S&rsquo; \in F&rsquo;$$, тоді і тільки тоді, коли $$\exists q \in F: (q_0, w) \models^\star (q, \varepsilon)$$.</p>
<p>Таким чином, $$L(M) = L(M&rsquo;)$$.</p>
<p>Побудований нами автомат $$M$$ має дві властивості: він детермінований та
повністю визначений. До того ж кількість станів цього автомата $$2^n - 1$$.</p>
<h1 id="_15">Мінімізація детермінованих скінченних автоматів<a class="headerlink" href="#_15" title="Permanent link"></a></h1>
<h2 id="_16">Мінімізація детермінованих скінченних автоматів<a class="headerlink" href="#_16" title="Permanent link"></a></h2>
<p>В подальшому при програмуванні скінченних автоматів важливо мати справу
з так званими &ldquo;мінімальними автоматами&rdquo;. <em>Мінімальним</em> для даного скінченого
автомата називається еквівалентний йому автомат з мінімальною кількістю станів.</p>
<p>Нагадаємо, що два автомати називаються <em>еквівалентними</em> якщо вони розпізнають одну мову.</p>
<p>Те, що скінчені автомати можна мінімізувати покажемо на наступному прикладі:</p>
<p><img alt="img-4" src="///C://Users/NikitaSkybytskyi/Desktop/c3s2/system-programming/lectures/img/img-4.png" /></p>
<p>Навіть при поверхневому аналізі діаграми переходів наведеного скінченого
автомата видно, що вершини $$q_3$$, $$q_4$$ та $$q_5$$ є &ldquo;зайвими&rdquo;, тобто при їх вилученні
новий автомат буде еквівалентний початковому. З наведеного вище прикладу
видно, що для отриманого детермінованого скінченого автомата можна
запропонувати еквівалентний йому автомат з меншою кількістю станів, тобто
мінімізувати скінчений автомат. Очевидно що серед зайвих станів цього
автомата є недосяжні та тупикові стани.</p>
<h3 id="_17">Недосяжні стани<a class="headerlink" href="#_17" title="Permanent link"></a></h3>
<p>Стан $$q$$ скінченого автомата $$M$$ називається <em>недосяжним</em>, якщо на
діаграмі переходів скінченого автомата не існує шляху з $$q_0$$ в $$q$$.</p>
<p><strong>Алгоритм [пошуку недосяжних станів].</strong> Спочатку спробуємо побудувати множину
досяжних станів. Якщо $$Q_m$$ &mdash; множина досяжних станів скінченого автомата $$M$$, то
$$Q \setminus Q_m$$ &mdash; множина недосяжних станів. Побудуємо послідовність множин $$Q_0, Q_1, Q_2, \ldots$$ таким чином, що:</p>
<ol>
<li>$$Q_0 = {q_0}$$.</li>
<li>$$Q_i = Q_{i-1} \cup \left{ q \mid \exists a \in \Sigma, q_j \in Q_{i - 1}: q \in \delta(q_j, a) \right}$$.</li>
<li>$$Q_m = Q_{m+1} = \ldots$$.</li>
</ol>
<p>Справді, очевидно, що кількість кроків скінчена, тому що послідовність $$Q_i$$
монотонна $$\left(Q_0 \subseteq Q_1 \subseteq Q_2 \subseteq \ldots\right)$$ 
та обмежена зверху: $$Q_m \subseteq Q$$.</p>
<p>Тоді $$Q_m$$ &mdash; множина досяжних станів скінченого автомата, 
а $$Q\setminus Q_m$$ &mdash; множина недосяжних станів.</p>
<p>Вилучимо з діаграми переходів скінченого автомата $$M$$ недосяжні вершини:</p>
<p><img alt="img-5" src="///C://Users/NikitaSkybytskyi/Desktop/c3s2/system-programming/lectures/img/img-5.png" /></p>
<p>В новому автоматі функція $$\delta$$ визначається лише для досяжних
станів. Побудований нами скінчений автомат з меншою кількістю станів буде
еквівалентний початковому.</p>
<h3 id="_18">Тупикові стани<a class="headerlink" href="#_18" title="Permanent link"></a></h3>
<p>Стан $$q$$ скінченого автомата $$M$$ називається <em>тупиковим</em>, якщо на
діаграмі переходів скінченого автомата не існує шляху з $$q$$ в $$F$$.</p>
<p><strong>Алгоритм [пошуку тупикових станів].</strong> Спочатку спробуємо знайти нетупикові
стани. Якщо $$S_m$$ &mdash; множина нетупикових станів, 
то $$Q \setminus S_m$$ &mdash; множина тупикових
станів. Побудуємо послідовність множин $$S_0, S_1, S_2, \ldots$$ таким чином, що:</p>
<ol>
<li>$$S_0 = F$$.</li>
<li>$$S_i = S_{i - 1} \cup \left{ q \mid \exists a \in \Sigma: \delta(q, a) \cap S_{i - 1} \ne \varnothing \right}$$.</li>
<li>$$S_m = S_{m + 1} = \ldots$$.</li>
</ol>
<p>Очевидно, що кількість кроків скінчена, тому що послідовність $$S_i$$
монотонна $$\left(S_0 \subseteq S_1 \subseteq S_2 \subseteq \ldots\right)$$ та обмежена зверху &mdash; $$S_m \subseteq Q$$.</p>
<p>Тоді $$S_m$$ &mdash; множина нетупикових станів скінченого автомата, 
а $$Q \setminus S_m$$ &mdash; множина тупикових станів. </p>
<p>Вилучимо з діаграми переходів скінченого автомата $$M$$ тупикові вершини:</p>
<p><img alt="img-6" src="///C://Users/NikitaSkybytskyi/Desktop/c3s2/system-programming/lectures/img/img-6.png" /></p>
<p>В новому автоматі функція $$\delta$$ визначається лише для нетупикових станів.</p>
<h3 id="_19">Еквівалентні стани<a class="headerlink" href="#_19" title="Permanent link"></a></h3>
<p>Автомат, у котрого відсутні недосяжні та тупикові стани, піддається
подальшій мінімізації шляхом &ldquo;склеювання&rdquo; еквівалентних станів.
Продемонструємо це на конкретному прикладі:</p>
<p><img alt="img-7" src="///C://Users/NikitaSkybytskyi/Desktop/c3s2/system-programming/lectures/img/img-7.png" /></p>
<p>Очевидно, що для наведеного вище скінченого автомата можна побудувати
еквівалентний йому скінчений автомат з меншою кількістю станів:</p>
<p><img alt="img-8" src="///C://Users/NikitaSkybytskyi/Desktop/c3s2/system-programming/lectures/img/img-8.png" /></p>
<p>Ми досягли бажаного нам результату шляхом &ldquo;склеювання&rdquo; двох станів $$q_1 \equiv q_3$$ та $$q_2 \equiv q_4$$.</p>
<p>Два стани $$q_1$$ та $$q_2$$ скінченого автомата $$M$$ називаються <em>еквівалентними</em> 
(позначається $$q_1 \equiv q_2$$),
якщо множини слів, які розпізнає автомат, починаючи з $$q_1$$ та $$q_2$$, співпадають.</p>
<p>Нехай $$q_1$$ та $$q_2$$ &mdash; два різні стани скінченого автомата $$M$$, 
а $$x \in \Sigma^\star$$. Будемо
говорити, що ланцюжок $$x$$ <em>розрізняє</em> стани $$q_1$$ та $$q_2$$, якщо $$(q_1,x) \models^\star (q_3, \varepsilon)$$ та $$(q_2,x) \models^\star (q_4, \varepsilon)$$, 
причому рівно один зі станів $$q_3$$ і $$q_4$$ (не) належить множині заключних станів.</p>
<p>Стани $$q_1$$ та $$q_2$$ називаються <em>$$k$$-нерозрізнені</em>, 
якщо не існує ланцюжка $$x$$ ($$\left|x\right| \le k$$),
що розрізняє стани $$q_1$$ та $$q_2$$. </p>
<p>Два стани $$q_1$$ та $$q_2$$ <em>нерозрізнені</em>, якщо вони
$$k$$-нерозрізнені для довільного $$k$$.</p>
<p><strong>Теорема.</strong> <em>Два стани $$q_1$$ та $$q_2$$ довільного скінченого автомата $$M$$ з $$n$$
станами нерозрізнені, якщо вони $$(n - 2)$$-нерозрізнені.</em></p>
<p><strong>Доведення:</strong> На першому кроці розіб&rsquo;ємо множину станів скінченого
автомата на дві підмножини: $$F$$ та $$Q \setminus F$$. 
На цій основі побудуємо відношення $$\equiv^0$$:
$$q_1 \equiv^0 q_2$$, якщо обидва стани одночасно належать $$F$$ або $$Q \setminus F$$.</p>
<p>Побудуємо відношення $$\equiv^k$$:
$$q_1 \equiv^k q_2$$, якщо $$q_1 \equiv^{k - 1} q_2$$ та $$\delta(q_1,а) \equiv^{k - 1} \delta(q_2, а)$$ для всіх $$а \in \Sigma$$.</p>
<p>Очевидно, кожна побудована множина містить не більше $$(n-1)$$ елементи.</p>
<p>Таким чином, можна отримати не більше $$(n-2)$$ уточнення відношення $$\equiv^0$$.</p>
<p>Відношення $$\equiv^{n - 2}$$ визначає класи еквівалентних станів автомата $$M$$.</p>
<h3 id="_20">Алгоритм<a class="headerlink" href="#_20" title="Permanent link"></a></h3>
<p><strong>Алгоритм [побудови мінімального скінченого автомата].</strong></p>
<ol>
<li>Побудувати скінчений автомат без тупикових станів.</li>
<li>Побудувати скінчений автомат без недосяжних станів.</li>
<li>Знайти множини еквівалентних станів та побудувати найменший
    (мінімальний) автомат.</li>
</ol>
<h1 id="-">Скінченно-автоматні мови і праволінійні граматики<a class="headerlink" href="#-" title="Permanent link"></a></h1>
<h2 id="-_1">Скінченно-автоматні мови<a class="headerlink" href="#-_1" title="Permanent link"></a></h2>
<p>Ознайомившись з деякими результатами теорії скінченних автоматів,
спробуємо з&rsquo;ясувати, які мови (множини слів) є скінчено-автоматними.</p>
<h3 id="_21">Базові мови<a class="headerlink" href="#_21" title="Permanent link"></a></h3>
<p><strong>Твердження:</strong> Скінчено автоматними є наступні множини:
1. порожня словарна множина &mdash; $$\varnothing$$;
2. словарна множина, що складається з одного $$\varepsilon$$-слова &mdash; $${\varepsilon}$$;
3. множина $${a}$$, $$a \in \Sigma$$.</p>
<p><strong>Доведення:</strong> в кожному випадку нам доведеться конструктивно побудувати
відповідний скінчений автомат:
1. Довільний скінчений автомат з пустою множиною заключних станів (а
    мінімальний &mdash; з пустою множиною станів) допускає $$\varnothing$$;
2. Розглянемо автомат $$M = \left\langle {q_0}, \Sigma, q_0, \delta, {q_0}\right\rangle$$,
    у якому $$\delta$$ не визначено ні для яких $$a \in \Sigma$$. Тоді $$L(M) = {\varepsilon}$$.
3. Розглянемо автомат 
    $$M = \left\langle {q_0, q_1}, \Sigma, q_0, \delta, {q_1}\right\rangle$$, 
    у якому функція $$\delta$$ визначена лише для пари $$(q_0, a)$$, а саме: 
    $$\delta(q_0, a) = {q_1}$$. Тоді $$L(M) = {a}$$.</p>
<h3 id="_22">Операції над мовами<a class="headerlink" href="#_22" title="Permanent link"></a></h3>
<p><strong>Твердження:</strong> Якщо $$M_1 = \left\langle Q_1, \Sigma, q_0^1, \delta_1, F_1 \right\rangle$$ 
та $$M_2 = \left\langle Q_2, \Sigma, q_0^2, \delta_2, F_2\right\rangle$$, що
визначають відповідно мови $$L(M_1)$$ та $$L(M_2)$$, то скінченно-автоматними мовами будуть:
1. $$L(M_1) \cup L(M_2) = \left{w \mid q \in L(M_1) \text{ or } q \in L(M_2)\right}$$;
2. $$L(M_1) \cdot L(M_2) = \left{w = xy \mid x \in L(M_1), y \in L(M_2) \right}$$;
3. $$L(M_1)^\star = {\varepsilon} \cup L(M_1) \cup L(M_1)^2 \cup L(M_1)^3 \cup \ldots$$.</p>
<p><strong>Доведення:</strong> в кожному випадку нам доведеться конструктивно побудувати
відповідний скінчений автомат:
1. Побудуємо автомат $$M = \left\langle Q, \Sigma, q_0, \delta, F \right\rangle$$ такий, що $$L(M) = L(M_1) \cup L(M_2)$$:
    - $$Q = Q_1 \cup Q_2 \cup {q_0}$$, де $$q_0$$ &mdash; новий стан 
        $$(q_0 \notin Q_1 \cup Q_2)$$;</p>
<div class="codehilite"><pre>- Функцію $$\delta$$ визначимо таким чином:

    $$
    \delta(q, a) = \begin{cases}
        \delta_1(q, a), &amp; q \in Q_1, \\
        \delta_2(q, a), &amp; q \in Q_2, \\
        \delta_1(q_0^1, a) \cup \delta_2(q_0^2, a), &amp; q = q_0. 
    \end{cases}
    $$

- Множина заключних станів:

    $$
    F = \begin{cases}
    F_1 \cup F_2, &amp; \text{if } \varepsilon \notin L_1 \cup L_2, \\
    F_1 \cup F_2 \cup \{q_0\}, &amp; \text{otherwise}.
    \end{cases}
    $$

Побудований таким чином автомат взагалі кажучи недетермінований.

Індукцією по $$i$$ показуємо, що $$(q_0, w) \models^i (q,\varepsilon)$$ 
тоді і тільки тоді, коли $$(q_0^1,w) \models^i (q,\varepsilon), q \in F_1$$ 
або $$(q_0^2,w) \models^i (q,\varepsilon), q \in F_2$$.
</pre></div>


<ol>
<li>
<p>Побудуємо автомат $$M = \left\langle Q, \Sigma, q_0, \delta, F \right\rangle$$ такий, що $$L(M) = L(M_1) \cdot L(M_2)$$:</p>
<ul>
<li>$$Q = Q_1 \cup Q_2$$;</li>
<li>$$q_0 = q_0^1$$;</li>
<li>
<p>Функцію $$\delta$$ визначимо таким чином:</p>
<p>$$
\delta(q, a) = \begin{cases}
\delta_1(q, a), &amp; q \in Q_1 \setminus F_1, \
\delta_2(q, a), &amp; q \in Q_2, \
\delta_1(q, a) \cup \delta_2(q_0^2,a), &amp; q \in F_1.
\end{cases}
$$</p>
</li>
<li>
<p>Множина заключних станів:</p>
<p>$$
F = \begin{cases}
F_2, &amp; \text{if } \varepsilon \notin L_2, \
F_1 \cup F_2, &amp; \text{otherwise}.
\end{cases}
$$</p>
</li>
</ul>
</li>
<li>
<p>Побудуємо автомат $$M = \left\langle Q, \Sigma, q_0, \delta, F \right\rangle$$ такий, що $$L(M) = L(M_1)^\star$$:</p>
<ul>
<li>$$Q = Q_1 \cup {q_0}$$, де $$q_0$$ &mdash; новий стан $$(q_0 \notin Q_1)$$;</li>
<li>
<p>Функцію $$\delta$$ визначимо таким чином:</p>
<p>$$
\delta (q, a) = \begin{cases}
\delta_1(q, a), &amp; q \in Q_1 \setminus F_1, \
\delta_1(q_0^1, a), &amp; q = q_0, \
\delta_1(q, a) \cup \delta_1(q_0^1, a), &amp; q \in F_1.
\end{cases}
$$</p>
</li>
<li>
<p>Множина заключних станів $$F = F_1 \cup {q_0}$$.</p>
</li>
</ul>
</li>
</ol>
<h2 id="_23">Скінченні автомати та праволінійні граматики<a class="headerlink" href="#_23" title="Permanent link"></a></h2>
<p><em>Породжуюча граматика</em> $$G$$ &mdash; це четвірка</p>
<p>$$
G = \left\langle N, \Sigma, P, S \right\rangle,
$$</p>
<p>де: 
- $$N$$ &mdash; скінченна множина &mdash; допоміжний алфавіт (нетермінали);
- $$\Sigma$$ &mdash; скінченна множина &mdash; основний алфавіт (термінали);
- $$P$$ &mdash; скінченна множина правил вигляду</p>
<div class="codehilite"><pre>$$
\alpha \mapsto \beta, \quad \alpha \in \left(N \cup \Sigma\right)^\star \times N \times \left(N \cup \Sigma\right)^\star, \quad \beta \in \left(N \cup \Sigma\right).
$$
</pre></div>


<ul>
<li>$$S$$ &mdash; виділений нетермінал (аксіома).</li>
</ul>
<h3 id="_24">Класифікація граматик Хомського<a class="headerlink" href="#_24" title="Permanent link"></a></h3>
<p>В залежності від структури правил граматики діляться на чотири типи:</p>
<ul>
<li>
<p>Тип 0: граматики загального вигляду, коли правила не мають обмежень, тобто</p>
<p>$$
\alpha \mapsto \beta, \quad \alpha \in \left(N \cup \Sigma\right)^\star \times N \times \left(N \cup \Sigma\right)^\star, \quad \beta \in \left(N \cup \Sigma\right).
$$</p>
</li>
<li>
<p>Тип 1: граматики, що не укорочуються, коли обмеження на правила
    мінімальні, а саме:</p>
<p>$$
\alpha \mapsto \beta, \quad \alpha \in \left(N \cup \Sigma\right)^\star \times N \times \left(N \cup \Sigma\right)^\star, \quad \beta \in \left(N \cup \Sigma\right), \quad |\alpha| \le |\beta|.
$$</p>
</li>
<li>
<p>Тип 2: контекстно-вільні граматики, коли правила в схемі $$P$$ мають вигляд:</p>
<p>$$
A_i \mapsto \beta, \quad A_i \in N, \quad \beta \in \left(N \cup \Sigma\right)^\star.
$$</p>
</li>
<li>
<p>Тип 3: скінченно-автоматні граматики, коли правила в схемі $$P$$ мають вигляд:</p>
<p>$$
A_i \mapsto w A_j, \quad A_i \mapsto w, \quad Ai \mapsto A_j w,
$$</p>
<p>де $$A_i, A_j \in N$$, $$w \in \Sigma^\star$$.</p>
</li>
</ul>
<p>В класі скінченно-автоматних граматик виділимо так звані <em>праволінійні
граматики</em> &mdash; це граматики, які в схемі Р мають правила вигляду:</p>
<p>$$
A_i \mapsto w A_j, \quad A_i \mapsto w,
$$</p>
<p>де $$A_i, A_j \in N$$, $$w \in \Sigma^\star$$.</p>
<p>Нескладно довести, що клас праволінійних граматик співпадає з класом граматик
типу 3.</p>
<h3 id="_25">Мова породжена граматикою<a class="headerlink" href="#_25" title="Permanent link"></a></h3>
<p>Ланцюжок $$w_1$$ <em>безпосередньо виводиться</em> з ланцюжка $$w$$
(позначається $$w \Rightarrow w_1$$), якщо $$w = x \alpha y$$, 
$$w_1 = x \beta y$$ та в схемі $$P$$ граматики $$G$$ є
правило виду $$\alpha \mapsto \beta$$. Оскільки поняття &ldquo;безпосередньо виводиться&rdquo;&rdquo;
розглядається на парах ланцюжків, то в подальшому символ $$\Rightarrow$$
буде трактуватися як бінарне відношення.</p>
<p>Ланцюжок $$w_1$$ <em>виводиться</em> з ланцюжка $$w$$ (позначається $$w \Rightarrow^\star w_1$$), якщо
існує скінчена послідовність виду $$w \Rightarrow w_1&rsquo; \Rightarrow w_2&rsquo; \Rightarrow \ldots \Rightarrow w_n&rsquo; \Rightarrow w_1$$. 
Або кажуть, що бінарне відношення $$\Rightarrow^\star$$ &mdash; 
це рефлексивно-транзитивне замикання бінарного відношення $$\Rightarrow$$.</p>
<p><em>Мова, яку породжує граматика</em> $$G$$ (позначається $$L(G)$$) &mdash; це множина
термінальних ланцюжків: </p>
<p>$$
L(G) = \left{ w \mid S \Rightarrow^\star w, w \in \Sigma^\star \right}.
$$</p>
<h3 id="sim">Праволінійна граматика $$\sim$$ скінченний автомат<a class="headerlink" href="#sim" title="Permanent link"></a></h3>
<p><strong>Теорема.</strong> <em>Клас мов, що породжуються праволінійними граматиками,
співпадає з класом мов, які розпізнаються скінченими автоматами.</em></p>
<p><strong>Доведення.</strong> Спочатку покажемо, що для довільної праволінійної граматики $$G$$
можна побудувати скінчений автомат $$M$$, такий що $$L(M) = L(G)$$.</p>
<p>Розглянемо правила праволінійної граматики. Вони бувають двох типів: $$A_i \mapsto w A_j$$, і $$A_i \mapsto w$$.</p>
<p>На основі правил граматики $$G$$ побудуємо схему $$P_1$$ нової граматики, яка буде
еквівалентною початковій, а саме:
- правила виду $$A_i \mapsto а_1 а_2 \ldots a_p A_j$$ замінимо послідовністю правил</p>
<div class="codehilite"><pre>$$
\begin{aligned}
A_i &amp;\mapsto a_1 B_1, \\
B_1 &amp;\mapsto a_2 B_2, \\
&amp;\ldots \\
B_{p - 1} &amp;\mapsto a_p A_j.
\end{aligned}
$$
</pre></div>


<ul>
<li>
<p>правила виду $$A_i \mapsto а_1 а_2 \ldots a_p$$ замінимо послідовністю правил</p>
<p>$$
\begin{aligned}
A_i &amp;\mapsto a_1 B_1, \
B_1 &amp;\mapsto a_2 B_2, \
&amp;\ldots \
B_{p - 1} &amp;\mapsto a_p B_p, \
B_p &amp;\mapsto \varepsilon.
\end{aligned}
$$</p>
</li>
</ul>
<p>де $$B_1, B_2, \ldots$$ &mdash; це нові нетермінали граматики $$G_1$$. 
Очевидно, що граматика $$G_1$$ буде еквівалентна граматиці $$G$$.</p>
<p>Далі, на основі граматики $$G_1$$ побудуємо скінчений автомат $$M$$, таким чином:
- як імена станів автомата візьмемо нетермінали граматики $$G_1$$;
- початковий стан автомата позначається аксіомою $$S$$;
- функція $$\delta$$ визначається діаграмою переходів, яка будується на основі правил
    вигляду $$A_i \mapsto a_k A_j$$:</p>
<div class="codehilite"><pre>![img-9](img/img-9.png)
</pre></div>


<ul>
<li>множина $$F$$ заключних станів скінченого автомата визначається так: 
    $$F = { A_i \mid A_i \mapsto \varepsilon }$$.</li>
</ul>
<p>Індукцією по довжині вхідного слова покажемо, що якщо $$S \Rightarrow^{n + 1} w$$, 
то $$(q_0, w) \models^n (q, \varepsilon)$$:
- База: $$i = 0$$: $$S \Rightarrow \varepsilon$$, тоді $$(q_0, \varepsilon) \models^0 (q_0, \varepsilon)$$.
- Перехід: нехай $$|w| = i + 1$$, тобто $$w = a w_1$$.
    Тоді $$S \Rightarrow a A_p \Rightarrow^i a w_1$$ та 
    $$(q_0, a w_1) \models (q_i, w_1) \models^{i - 1} (q, \varepsilon)$$, де $$q \in F$$.</p>
<p>Доведення навпаки є очевидним.</p>
<h1 id="_26">Регулярні множини і регулярні вирази<a class="headerlink" href="#_26" title="Permanent link"></a></h1>
<h2 id="_27">Регулярні множини<a class="headerlink" href="#_27" title="Permanent link"></a></h2>
<p>Нехай $$\Sigma$$ &mdash; скінчений алфавіт. <em>Регулярна множина</em> в алфавіті $$\Sigma$$
визначається рекурсивно:
1. $$\varnothing$$ &mdash; пуста множина &mdash; це регулярна множина в алфавіті $$\Sigma$$;
2. $${\varepsilon}$$ &mdash; пусте слово &mdash; регулярна множина в алфавіті $$\Sigma$$;
3. $${a}$$ &mdash; однолітерна множина &mdash; регулярна множина в алфавіті $$\Sigma$$;
4. Якщо $$P$$ та $$Q$$ &mdash; регулярні множини, то такими є наступні множини:
    - $$P \cup Q$$ (операція об&rsquo;єднання);
    - $$P \times Q$$ (операція конкатенації);
    - $$P^\star = {\varepsilon} \cup P \cup P^2 \cup \ldots$$ (операція ітерації).
5. Ніякі інші множини, окрім побудованих на основі 1&ndash;4 не є регулярними множинами.</p>
<p>Таким чином, регулярні множини можна побудувати з базових елементів
1-3 шляхом скінченого застосування операцій об&rsquo;єднання, конкатенації та
ітерації.</p>
<h2 id="_28">Регулярні вирази<a class="headerlink" href="#_28" title="Permanent link"></a></h2>
<p>Регулярні вирази позначають регулярні множини таким чином, що:
1. $$0$$ позначає регулярну множину $$\varnothing$$;
2. $$\varepsilon$$ позначає регулярну множину $${\varepsilon}$$;
3. $$a$$ позначає регулярну множину $${a}$$;
4. Якщо $$p$$ та $$q$$ позначають відповідно регулярні множини $$P$$ та $$Q$$, то
    - $$p + q$$ позначає регулярну множину $$P \cup Q$$;
    - $$p \cdot q$$ позначає регулярну множину $$P \times Q$$;
    - $$p^\star$$ позначає регулярну множину $$P^\star$$.
5. Ніякі інші вирази, окрім побудованих на основі 1&ndash;4 не є регулярними виразами.</p>
<h3 id="_29">Алгебра регулярних виразів<a class="headerlink" href="#_29" title="Permanent link"></a></h3>
<p>Оскільки ми почали вести мову про вирази, нам зручніше перейти до поняття
алгебри регулярних виразів. Для кожної алгебри одним з важливих питань є
питання еквівалентних перетворень, які виконуються на основі тотожностей у цій
алгебрі. Сформулюємо основні тотожності алгебри регулярних виразів:</p>
<ol>
<li>$$a + b + c = a + (b + c)$$ (ліва асоціативність додавання);</li>
<li>$$a + b + c = (a + b) + c$$ (права асоціативність додавання);</li>
<li>$$a + 0 = 0 + a = a$$ ($$0$$ &mdash; нейтральний елемент за додаванням);</li>
<li>$$a \cdot b \cdot c = a \cdot (b \cdot c)$$ (ліва асоціативність множення);</li>
<li>$$a \cdot b \cdot c = (a \cdot b) \cdot c$$ (права асоціативність множення);</li>
<li>$$a + b = b + a$$ (комутативність додавання);</li>
<li>$$a \cdot \varepsilon = \varepsilon \cdot a = a$$ ($$\varepsilon$$ &mdash; нейтральний елемент за множенням);</li>
<li>$$a \cdot 0 = 0 \cdot a = 0$$ ($$0$$ &mdash; нульовий елемент за множенням);</li>
<li>$$a \cdot (b + c) = a \cdot b + a \cdot c$$ (ліва дистрибутивність множення відносно додавання);</li>
<li>$$(a + b) \cdot c = a \cdot c + b \cdot c$$ (права дистрибутивність множення відносно додавання).</li>
</ol>
<p>У алгебри регулярних виразів є і некласичні властивості:</p>
<ol>
<li>$$a + a = a$$;</li>
<li>$$p + p^\star = p^\star$$;</li>
<li>$$0^\star = \varepsilon$$;</li>
<li>$$\varepsilon^\star = \varepsilon$$.</li>
</ol>
<h3 id="_30">Лінійні рівняння<a class="headerlink" href="#_30" title="Permanent link"></a></h3>
<p>За аналогією з класичними алгебрами розглянемо лінійне рівняння в алгебрі
регулярних виразів: $$X = a \cdot X + b$$, де $$a$$, $$b$$ &mdash; регулярні вирази.</p>
<p>Взагалі кажучи таке рівняння (в залежності від $$a$$ та $$b$$) може мати безліч розв&rsquo;язків,</p>
<p>Серед всіх розв&rsquo;язків рівняння з регулярними
коефіцієнтами виберемо найменший розв&rsquo;язок $$X = a^\star \cdot b$$, який назвемо <em>найменша
нерухома точка.</em> </p>
<p>Щоб перевірити, що $$a^\star \cdot b$$ справді розв&rsquo;язок рівняння в алгебрі регулярних
виразів, підставимо його в початкове рівняння та перевіримо тотожність виразів
на основі системи тотожних перетворень:</p>
<p>$$
a^\star b = a a^\star b = (a a^\star + \varepsilon) b = (a (\varepsilon + a + a^2 + \ldots ) + \varepsilon) b = (\varepsilon a + a^2 + \ldots) b = a^\star b.
$$</p>
<h3 id="_31">Системи рівнянь<a class="headerlink" href="#_31" title="Permanent link"></a></h3>
<p>В алгебрі регулярних виразів також розглядають і системи лінійних рівнянь з
регулярними коефіцієнтами:</p>
<p>$$
\left{
\begin{aligned}
X_1 &amp;= a_{11} X_1 + a_{12} X_2 + \ldots + a_{1n} X_n + b_1, \
X_2 &amp;= a_{21} X_1 + a_{22} X_2 + \ldots + a_{2n} X_n + b_2, \
&amp;\ldots \
X_n &amp;= a_{n1} X_1 + a_{n2} X_2 + \ldots + a_{nn} X_n + b_n.
\end{aligned}
\right.
$$</p>
<p>Метод розв&rsquo;язування системи лінійних рівнянь з регулярними коефіцієнтами
нагадує метод виключення Гауса.
1. Для $$i = \overline{1..n}$$, використавши систему
    тотожних перетворень, записати  $$i$$-е рівняння у вигляді:
    $$X_i = a X_i + b$$, де $$a$$ &mdash; регулярний вираз в алфавіті $$\Sigma$$, 
    а $$b$$ &mdash; регулярний вираз виду </p>
<div class="codehilite"><pre>$$
\beta_0 + \beta_{i+1} X_{i+1} + \beta_{i+2} X_{i+2} + \ldots + \beta_n X_n,
$$

де $$\beta_k$$ ($$k = 0, \overline{i+1..n}$$) &amp;mdash; регулярні коефіцієнти. Далі,
в правих частинах рівнянь зі змінними $$X_{i+1}, X_{i+2}, \ldots, X_n$$ в лівій частині рівняння підставити замість $$X_i$$ значення $$a^\star b$$.
</pre></div>


<ol>
<li>Для $$i = \overline{n..1}$$ розв&rsquo;язати $$i$$-е рівняння 
    яке зараз має вигляд $$X_i = a X_i + b$$, де $$a$$, $$b$$ &mdash; 
    регулярні вирази в алфавіті $$\Sigma$$, і підставити його розв&rsquo;язок $$a^\star b$$
    у коефіцієнти рівнянь зі змінними $$X_{i-1}, X_{i-2}, \ldots, X_1$$.</li>
</ol>
<p><strong>Приклад.</strong> Розв&rsquo;язати систему $$2\times2$$:</p>
<p>$$
\left{
\begin{aligned}
X_1 &amp;= a_{11} X_1 + a_{12} X_2 + b_1, \
X_2 &amp;= a_{21} X_1 + a_{22} X_2 + b_2.
\end{aligned}
\right.
$$</p>
<p><strong>Розв&rsquo;язок:</strong></p>
<ol>
<li>
<p>З першого рівняння </p>
<p>$$
X_1 = a_{11}^\star (a_{12} X_2 + b_1).
$$</p>
</li>
<li>
<p>Підставляємо у друге рівняння, воно набуває вигляду</p>
<p>$$
X_2 = a_{21} (a_{11}^\star (a_{12} X_2 + b_1)) + a_{22} X_2 + b_2.
$$</p>
<p>Або, після спрощень:</p>
<p>$$
X_2 = (a_{21} a_{11}^\star a_{12} + a_{22}) X_2 + (a_{21} a_{11}^\star b_1 + b_2).
$$</p>
<p>Звідки знаходимо:</p>
<p>$$
X_2 = (a_{21} a_{11}^\star a_{12} + a_{22})^\star (a_{21} a_{11}^\star b_1 + b_2).
$$</p>
</li>
<li>
<p>Підставляємо у вираз для $$X_1$$:</p>
<p>$$
X_1 = a_{11}^\star (a_{12} (a_{21} a_{11}^\star a_{12} + a_{22})^\star (a_{21} a_{11}^\star b_1 + b_2) + b_1).
$$</p>
<p>Тут можна розкрити дужки, але зараз у цьому немає потреби.</p>
</li>
</ol>
<h1 id="_32">ПОЛІЗ, регулярні вирази і автомати<a class="headerlink" href="#_32" title="Permanent link"></a></h1>
<h2 id="_33">Польський інверсний запис для регулярних виразів<a class="headerlink" href="#_33" title="Permanent link"></a></h2>
<p>Польський інверсний запис (ПОЛІЗ) для регулярних виразів будується на
основі початкового регулярного виразу на основі наступних правил:
1. Порядок операндів в початковому виразі і в перетвореному виразі співпадають.
2. Операції в перетвореному виразу йдуть з урахуванням пріоритету
    безпосередньо за операндами.</p>
<p>Наприклад, ПОЛІЗ для виразу $$(a^\star+b)^\star c$$ має такий вигляд: $$a, \star, b, +, \star, c, \cdot$$.</p>
<p>В цьому прикладі в стандартному записі регулярного виразу бінарна операція
конкатенація $$\cdot$$ природньо опущена, але в ПОЛІЗ потрібно завжди цю операцію
явно вказувати. </p>
<p>Важливою характеристикою ПОЛІЗ є відсутність дужок в запису
виразу, тобто його можна опрацьовувати лінійно.</p>
<h3 id="_34">Алгоритм<a class="headerlink" href="#_34" title="Permanent link"></a></h3>
<p>Для перетворення виразу в ПОЛІЗ необхідно з кожною операцією зв&rsquo;язати
деяке число, яке будемо називати &ldquo;пріоритет&rdquo; (0 &mdash; найвищий пріоритет присвоїмо
дужці <code>'('</code>). Наведемо псевдокод алгоритму:</p>
<div class="codehilite"><pre>while lexem &lt;- прочитати поточну лексему:
    if lexem is операнд:
        занести її в поле результату

    if lexem = &#39;(&#39;:
        занести її в стек

    if lexem is код операції:
        while пріоритет операції на вершині стека &gt;= пріоритет поточної операції:
            елемент з вершини стека перенести в поле результату
        поточну лексему занести в стек

    if lexem = &#39;)&#39;:
        while код операції на вершині стеку != &#39;(&#39;:
            елемент з вершини стека перенести в поле результату
        дужку &#39;(&#39; зняти з вершини стека

всі елементи із стека перенести в поле результату
</pre></div>

<h2 id="_35">Інтерпретація ПОЛІЗ регулярного виразу<a class="headerlink" href="#_35" title="Permanent link"></a></h2>
<p>Результат інтерпретації ПОЗІЗ &mdash; це скінченний автомат $$M$$, який розпізнає
(сприймає) множину ланцюжків, котрі позначає регулярний вираз.</p>
<h3 id="_36">Алгоритм<a class="headerlink" href="#_36" title="Permanent link"></a></h3>
<p>Наведемо псевдокод алгоритму:</p>
<div class="codehilite"><pre>while lexem &lt;- прочитати поточну лексему:
    if lexem is операнд ai:
        M: L(M) = {ai}

    if lexem = &#39;+&#39;:
        M1, M2 &lt;- автомати з вершини стеку
        M: L(M) = L(M1) ∪ L(M2)

    if lexem = &#39;×&#39;:
        M1, M2 &lt;- автомати з вершини стеку
        M: L(M) = L(M2) × L(M1)

    if lexem = &#39;★&#39;:
        M1 &lt;- автомат з вершини стеку
        M: L(M)= L(M1)★

    M занести в стек

вершину стека перенести в поле результату
</pre></div>

<p>Якщо досягли кінця регулярного виразу, то на вершині стека знаходиться
автомат $$M$$, який розпізнає множину слів (ланцюжків), які позначає
регулярний вираз.</p>
<h1 id="_37">Синтаксичний аналіз в мовних процесорах<a class="headerlink" href="#_37" title="Permanent link"></a></h1>
<h2 id="_38">Синтаксичний аналіз<a class="headerlink" href="#_38" title="Permanent link"></a></h2>
<p>Для визначення синтаксичної компоненти мови програмування
використовують контекстно-вільні граматики (КС-граматики). На відміну від
скінченно-автоматних граматик потужність класу КС-граматик достатня, щоб
визначити майже всі так звані синтаксичні властивості мов програмування.
Якщо цього недостатньо, то розглядають деякі спрощення у граматиках типу 2
або параметричні КC-граматики.</p>
<p>Звичайно, із синтаксичною компонентою мови програмування пов&rsquo;язана
семантична компонента. Тоді, якщо ми говоримо про семантику мови
програмування, ми вимагаємо семантичної однозначності для кожної вірно
написаної програми. За аналогією з семантикою, при описі синтаксичної
компоненти мови програмування необхідно користуватися однозначними
граматиками.</p>
<p>Граматика $$G$$ називається <em>неоднозначною</em>, якщо існує декілька
варіантів виводу $$\omega$$ в $$G$$ $$\left(\omega \in L(G)\right)$$.</p>
<p><strong>Приклад.</strong> Розглянемо таку граматику $$G = \left\langle N, \Sigma, P, S\right\rangle$$ з двома правилами у схемі $$P$$: $$S \Rightarrow S + S$$, і $$S \Rightarrow a$$. Покажемо, що для ланцюжка $$\omega = a + a + a$$ існує щонайменше два варіанти виводу:
1. $$S \Rightarrow S + S \Rightarrow S + S + S \Rightarrow a + S + S \Rightarrow a + a + S \Rightarrow a + a + a$$.
2. $$S \Rightarrow S + S \Rightarrow a + S \Rightarrow a + S + S \Rightarrow a + a + S \Rightarrow a + a + a$$.</p>
<h3 id="_39">Стратегії виведення<a class="headerlink" href="#_39" title="Permanent link"></a></h3>
<p>В теорії граматик розглядається декілька стратегій виведення ланцюжка $$\omega$$ в $$G$$.
Визначимо дві стратегії, які будуть використані в подальшому.</p>
<p><em>Лівостороння стратегія виводу</em> ланцюжка $$\omega$$ в $$G$$ &mdash; це послідовність кроків
безпосереднього виводу, при якій на кожному кроку до уваги береться перший
зліва направо нетермінал. </p>
<p><em>Правостороння стратегія виводу</em> $$\omega$$ в $$G$$ протилежна
лівосторонній стратегії. </p>
<p>З виводом $$\omega$$ в $$G$$ пов&rsquo;язане синтаксичне дерево, яке
визначає синтаксичну структуру програми.</p>
<h3 id="_40">Синтаксичні дерева<a class="headerlink" href="#_40" title="Permanent link"></a></h3>
<p><em>Синтаксичне дерево виведення</em> $$\omega$$ в $$G$$ &mdash; це впорядковане дерево,
корінь котрого позначено аксіомою, в проміжних вершинах знаходяться
нетермінали, а на кроні &mdash; елементи з $$\Sigma \cup {\varepsilon}$$. Побудова 
синтаксичного дерева виведення $$\omega$$ в $$G$$ виконується покроково з урахуванням стратегії 
виводу $$\omega$$ в $$G$$.</p>
<p><strong>Алгоритм [побудови синтаксичного дерева ланцюжка $$\omega$$ в граматиці $$G$$ урахуванням лівосторонньої стратегії виводу].</strong></p>
<ol>
<li>
<p>Будуємо корінь дерева та позначимо його аксіомою $$S$$.</p>
</li>
<li>
<p>В схемі $$P$$ граматики $$G$$ візьмемо правило виду 
    $$S \Rightarrow \alpha_1 \alpha_2 \ldots \alpha_p$$, де 
    $$\alpha_i \in N \cup \Sigma \cup {\varepsilon} $$
    і побудуємо дерево висоти 1: </p>
<p><img alt="img-10" src="///C://Users/NikitaSkybytskyi/Desktop/c3s2/system-programming/lectures/img/img-10-1.png" /></p>
</li>
<li>
<p>На кроні дерева, побудованого на попередньому кроці, візьмемо перший зліва
    направо нетермінал. Нехай це буде $$\alpha_i$$. Тоді в схемі $$P$$ виберемо правило виду
    $$\alpha_i \Rightarrow \beta_1 \beta_2 \ldots \beta_l$$, де 
    $$\beta_i \in N \cup \Sigma \cup {\varepsilon}$$
    і побудуємо наступне дерево: </p>
<p><img alt="img-11" src="///C://Users/NikitaSkybytskyi/Desktop/c3s2/system-programming/lectures/img/img-11-1.png" /></p>
<p>Цей крок виконується доки на кроні дерева є елементи з $$N$$.</p>
</li>
</ol>
<p>Зауважимо очевидні факти, що випливають з побудови синтаксичного дерева:
- крона дерева, зображеного на попередньому малюнку наступна: 
    $$\alpha_1 \alpha_2 \ldots \alpha_{i - 1} \beta_1 \beta_2 \ldots \beta_l \alpha_{i + 1} \ldots \alpha_p$$;
- ланцюжок $$\alpha_1 \alpha_2 \ldots \alpha_{i - 1} \in \Sigma^\star$$ з крони &mdash;
    термінальний ланцюжок;
- для однозначної граматики $$G$$ існує лише одне синтаксичне дерево виводу $$\omega$$ в
    $$G$$.</p>
<h3 id="_41">Власне аналіз<a class="headerlink" href="#_41" title="Permanent link"></a></h3>
<p>Будемо говорити, що ланцюжок $$\omega \in \Sigma^\star$$, побудований на основі
граматики $$G$$ $$\left(\omega \in L(G)\right)$$ <em>проаналізований</em>, 
якщо відоме одне з його дерев виводу.</p>
<p>Зафіксуємо послідовність номерів правил, які були використані під час побудови
синтаксичного дерева виводу $$\omega$$ в $$G$$ з урахуванням стратегії виводу.</p>
<p><em>Лівостороннім аналізом</em> $$\pi$$ ланцюжка $$\omega \in L(G)$$ будемо називати
послідовність номерів правил, які були використані при лівосторонньому виводі
$$\omega$$ в $$G$$.</p>
<p><strong>Приклад:</strong> Для граматики $$G = \left\langle N, \Sigma, P, S\right\rangle$$ зі схемою $$P$$:</p>
<p>$$
\begin{align}
S &amp;\Rightarrow S + T \
S &amp;\Rightarrow T \
T &amp;\Rightarrow T \times F \
T &amp;\Rightarrow F \
F &amp;\Rightarrow (S) \
F &amp;\Rightarrow a \
\end{align}
$$</p>
<p>і для ланцюжка $$\omega = a \times (a + a)$$ побудуємо лівосторонній аналіз $$\pi$$:</p>
<p>Виведення має вигляд:</p>
<p>$$
\begin{multline<em>}
S \Rightarrow T \Rightarrow T \times F \Rightarrow F \times F \Rightarrow a \times F \Rightarrow a \times (S) \Rightarrow a \times (S + T) \Rightarrow \
\Rightarrow a \times (T + T) \Rightarrow a \times (F + T) \Rightarrow a \times (a + T) \Rightarrow a \times (a + F) \Rightarrow a \times (a + a).
\end{multline</em>}
$$</p>
<p>З наведеного вище виводу ланцюжка $$\omega \in L(G)$$ лівосторонній аналіз $$\pi$$ буде:
$$\pi = (2, 3, 4, 6, 5, 1, 2, 4, 6, 4, 6)$$, а синтаксичне дерево виводу $$\omega = a \times (a + a)$$ наступне:</p>
<p><img alt="img-12" src="///C://Users/NikitaSkybytskyi/Desktop/c3s2/system-programming/lectures/img/img-12.png" /></p>
<h3 id="_42">Синтез дерева за аналізом<a class="headerlink" href="#_42" title="Permanent link"></a></h3>
<p>Нехай $$\pi$$ &mdash; лівосторонній аналіз ланцюжка $$\omega \in L(G)$$. Знаючи $$\pi$$ досить легко
побудувати (відтворити) синтаксичне дерево. Відтворення (синтез) синтаксичного
дерева можна виконати, скориставшись однією з стратегій синтаксичного аналізу:
- стратегія &ldquo;зверху донизу&rdquo;;
- стратегія &ldquo;знизу догори&rdquo;.</p>
<p>Стратегія синтаксичного аналізу <em>&ldquo;зверху донизу&rdquo;</em> &mdash; це побудова синтаксичного
дерева крок за кроком починаючи від кореня до крони.</p>
<p><strong>Алгоритм [синтезу синтаксичного дерева на основі лівостороннього аналізу
$$\pi$$ ланцюжка $$\omega \in L(G)$$].</strong></p>
<ol>
<li>Побудуємо корінь дерева та позначимо його аксіомою $$S$$. Тоді, якщо
    $$\pi = (p_1, p_2, \ldots, p_m)$$, то</li>
<li>
<p>Побудуємо дерево висоти один, взявши зі схеми $$P$$ правило з номером $$p_1$$ виду
    $$S \Rightarrow \alpha_1 \alpha_2 \ldots \alpha_p$$:</p>
<p><img alt="img-13" src="///C://Users/NikitaSkybytskyi/Desktop/c3s2/system-programming/lectures/img/img-13-1.png" />
3. На кроні дерева, отриманого на попередньому кроку, візьмемо перший зліва
направо нетермінал (нехай це буде нетермінал $$\alpha_i$$) та правило з номером $$p_j$$ вигляду: $$\alpha_i \Rightarrow \beta_1 \beta_2 \ldots \beta_l$$ та побудуємо нове дерево:</p>
<p><img alt="img-14" src="///C://Users/NikitaSkybytskyi/Desktop/c3s2/system-programming/lectures/img/img-14-1.png" /></p>
<p>Даний пункт виконувати доти, доки не переглянемо всі елементи з $$\pi$$.</p>
</li>
</ol>
<h3 id="_43">Проблеми стратегії &ldquo;зверху донизу&rdquo;<a class="headerlink" href="#_43" title="Permanent link"></a></h3>
<p>Сформулюємо декілька проблему для стратегії аналізу &ldquo;зверху донизу&rdquo;:</p>
<p>У загальному випадку у класі КС-граматик існує проблема неоднозначності
(недетермінізму) виводу $$\omega \in L(G)$$. Як приклад можемо розглянути граматику з
&ldquo;циклами&rdquo;. Це така граматика, у якої в схемі $$P$$ існує така послідовність правил
за участю нетермінала $$A_i$$, що: $$A_i \Rightarrow A_j$$ і $$A_j \Rightarrow A_i$$, де $$A_j$$ &mdash; будь-який нетермінал граматики $$G$$. </p>
<p>Як наслідок, граматики з ліворекурсивним нетерміналом
для стратегії аналізу &ldquo;зверху донизу&rdquo; недопустимі. <!--це ж чому?--></p>
<p>Зауважимо, що існують підкласи класу КС-граматик, які природно забезпечують стратегію
аналізу &ldquo;зверху донизу&rdquo;. Один з таких підкласів &mdash; це $$LL(k)$$-граматики, які
забезпечують синтаксичний аналіз ланцюжка $$\omega \in L(G)$$ за час $$O(n)$$, 
де $$n = \mid \omega \mid$$, та при цьому аналіз є однозначним.</p>
<p><a href="///C://Users/NikitaSkybytskyi/Desktop/c3s2/system-programming/README.md">Назад на головну</a></p></article></body></html>